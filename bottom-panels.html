<div v-scope="BottomPanels($root)" class="bottom-section">
    <div class="timeline-container">
        <div class="timeline-header">
            <div class="timeline-header-thumb">
                <img v-if="$root.selectedImage" :src="$root.selectedImage.base64Data">
            </div>
            <div class="timeline-controls-wrapper">
                <div v-if="$root.selectedImage && $root.selectedBlock" class="edit-form">
                    <h4>Edit {{ $root.selectedBlock.type }} Animation</h4>
                    <div class="form-grid" @input="$root.updatePreview">
                        <div><label>Start Time (s)</label><input type="number" v-model.number="$root.selectedBlock.startTime" min="0" step="0.1"></div>
                        <div><label>Duration (s)</label><input type="number" v-model.number="$root.selectedBlock.duration" min="0.1" step="0.1"></div>
                        <template v-if="$root.selectedBlock.type === 'pan'">
                            <div><label>Direction</label><select v-model="$root.selectedBlock.parameters.direction"><option>left</option><option>right</option><option>up</option><option>down</option></select></div>
                            <div><label>Distance (px)</label><input type="number" v-model.number="$root.selectedBlock.parameters.distance"></div>
                        </template>
                        <template v-if="$root.selectedBlock.type === 'zoom'">
                            <div><label>Start Scale</label><input type="number" step="0.1" v-model.number="$root.selectedBlock.parameters.startScale"></div>
                            <div><label>End Scale</label><input type="number" step="0.1" v-model.number="$root.selectedBlock.parameters.endScale"></div>
                            <div><label>Center X (px)</label><input type="number" v-model.number="$root.selectedBlock.parameters.zoomX" :disabled="$root.selectedBlock.parameters.useCenter"></div>
                            <div><label>Center Y (px)</label><input type="number" v-model.number="$root.selectedBlock.parameters.zoomY" :disabled="$root.selectedBlock.parameters.useCenter"></div>
                        </template>
                        <template v-if="$root.selectedBlock.type === 'rotate'">
                            <div><label>Degrees</label><input type="number" v-model.number="$root.selectedBlock.parameters.degrees"></div>
                            <div><label>Center X (px)</label><input type="number" v-model.number="$root.selectedBlock.parameters.rotateX" :disabled="$root.selectedBlock.parameters.useCenter"></div>
                            <div><label>Center Y (px)</label><input type="number" v-model.number="$root.selectedBlock.parameters.rotateY" :disabled="$root.selectedBlock.parameters.useCenter"></div>
                        </template>
                        <template v-if="$root.selectedBlock.type === 'opacity'">
                            <div><label>Start Opacity</label><input type="number" step="0.1" min="0" max="1" v-model.number="$root.selectedBlock.parameters.startOpacity"></div>
                            <div><label>End Opacity</label><input type="number" step="0.1" min="0" max="1" v-model.number="$root.selectedBlock.parameters.endOpacity"></div>
                        </template>
                    </div>
                     <div class="form-footer">
                         <div class="checkbox-group" @change="$root.updatePreview">
                             <label class="loop-toggle"><input type="checkbox" v-model="$root.selectedBlock.loop"> Loop</label>
                             <template v-if="$root.selectedBlock.parameters.hasOwnProperty('autoReverse')">
                                 <label class="loop-toggle"><input type="checkbox" v-model="$root.selectedBlock.parameters.autoReverse"> Auto-Reverse</label>
                             </template>
                             <template v-if="$root.selectedBlock.type === 'rotate'">
                                 <label class="loop-toggle"><input type="checkbox" v-model="$root.selectedBlock.parameters.useCenter"> Rotate Around Center</label>
                             </template>
                             <template v-if="$root.selectedBlock.type === 'zoom'">
                                 <label class="loop-toggle"><input type="checkbox" v-model="$root.selectedBlock.parameters.useCenter"> Zoom From Center</label>
                             </template>
                         </div>
                         <button class="delete-btn" @click="deleteAnimationBlock($root.selectedBlock.id)">Delete Block</button>
                     </div>
                </div>
                <div v-else class="timeline-controls">
                    <h4>Add Animation Block</h4>
                    <div class="button-group">
                      <button @click="addAnimationBlock('pan')" :disabled="!$root.selectedImage">Pan</button>
                      <button @click="addAnimationBlock('zoom')" :disabled="!$root.selectedImage">Zoom</button>
                      <button @click="addAnimationBlock('rotate')" :disabled="!$root.selectedImage">Rotate</button>
                      <button @click="addAnimationBlock('opacity')" :disabled="!$root.selectedImage">Opacity</button>
                    </div>
                </div>
            </div>
        </div>
        <div class="timeline-rows-wrapper" ref="timelineWrapper" @dragover.prevent="onBlockDragOver" @dragleave="onBlockDragLeave" @drop="onBlockDrop">
            <div class="time-ruler">
                <div v-for="mark in $root.timelineMarks.tenths" :key="'tenth-' + mark" class="ruler-line tenth" :style="{ left: mark + '%' }"></div>
                <div v-for="mark in $root.timelineMarks.seconds" :key="'sec-' + mark.pos" class="ruler-line second" :style="{ left: mark.pos + '%' }"></div>
                <div v-for="mark in $root.timelineMarks.seconds" :key="'label-' + mark.pos" class="ruler-label" :style="{ left: mark.pos + '%' }">{{ mark.label }}s</div>
            </div>
            <div v-if="$root.dragPlaceholder.visible" class="drag-placeholder" :style="{ left: $root.dragPlaceholder.left, width: $root.dragPlaceholder.width, top: $root.dragPlaceholder.top, height: $root.dragPlaceholder.height }"></div>
            <div v-for="rowIndex in [0, 1, 2]" :key="rowIndex" class="timeline-row" :data-row-index="rowIndex">
                <div
                    v-for="block in getBlocksForRow(rowIndex)"
                    :key="block.id"
                    class="animation-block"
                    :class="[block.type, { 'selected': $root.selectedBlock && $root.selectedBlock.id === block.id }]"
                    :style="{ left: `${(block.startTime / $root.timelineDuration) * 100}%`, width: `${(block.duration / $root.timelineDuration) * 100}%` }"
                    draggable="true"
                    @dragstart="onBlockDragStart($event, block)"
                    @click="selectBlock(block)"
                >
                    <img v-if="getImageForBlock(block)" :src="getImageForBlock(block).base64Data" class="block-thumbnail">
                    <span>{{ block.type }}</span>
                </div>
            </div>
            <div v-if="$root.overlapError" class="error-message">Cannot drop here: Overlap detected.</div>
        </div>
    </div>
</div>
<script>
function BottomPanels($root) {
  return {
    getBlocksForRow(rowIndex) {
      const allBlocks = $root.project.images.flatMap(img =>
        img.animationBlocks.map(b => ({...b, imageId: img.id}))
      );
      return allBlocks.filter(b => b.rowIndex === rowIndex);
    },
    getImageForBlock(block) {
      return $root.project.images.find(img => img.id === block.imageId);
    },
    addAnimationBlock(type) {
      if (!$root.selectedImage) return;
      const allBlocks = $root.project.images.flatMap(img => img.animationBlocks);
      let targetRow = 0;
      for (let i = 0; i < 3; i++) {
        const blocksOnRow = allBlocks.filter(b => b.rowIndex === i);
        const hasOverlap = blocksOnRow.some(b => (0 < b.startTime + b.duration) && (2 > b.startTime));
        if (!hasOverlap) {
          targetRow = i;
          break;
        }
      }
      const defaultParams = {
        pan: { direction: 'right', distance: 100, autoReverse: true },
        zoom: { startScale: 1, endScale: 1.5, autoReverse: true, useCenter: true, zoomX: 0, zoomY: 0 },
        rotate: { degrees: 90, autoReverse: false, useCenter: true, rotateX: 0, rotateY: 0 },
        opacity: { startOpacity: 1, endOpacity: 0, autoReverse: true },
      };
      const newBlock = {
        id: `anim_${Date.now()}`, type, startTime: 0, duration: 2, loop: true,
        rowIndex: targetRow,
        parameters: defaultParams[type],
      };
      $root.selectedImage.animationBlocks.push(newBlock);
      this.selectBlock(newBlock);
      $root.updatePreview();
    },
    deleteAnimationBlock(id) {
      $root.project.images.forEach(img => {
        img.animationBlocks = img.animationBlocks.filter(b => b.id !== id);
      });
      if ($root.selectedBlock && $root.selectedBlock.id === id) { $root.selectedBlock = null; }
      $root.updatePreview();
    },
    selectBlock(block) {
      const image = this.getImageForBlock(block);
      if (image) {
        const originalBlock = image.animationBlocks.find(b => b.id === block.id);
        if (originalBlock) {
          $root.project.selectedImageId = image.id;
          $root.selectedBlock = originalBlock;
        }
      }
    },
    onBlockDragStart(event, block) {
      const rect = event.target.getBoundingClientRect();
      $root.draggedBlockInfo = {
        block: block,
        offset: event.clientX - rect.left,
      };
      event.dataTransfer.setData('text/plain', block.id);
      event.dataTransfer.effectAllowed = 'move';
    },
    onBlockDragOver(event) {
      if (!$root.draggedBlockInfo) return;
      event.preventDefault();
      const timelineRect = this.$refs.timelineWrapper.getBoundingClientRect();
      const rowHeight = timelineRect.height / 3;
      const dropX = event.clientX - timelineRect.left - $root.draggedBlockInfo.offset;
      const dropY = event.clientY - timelineRect.top;
      const rawTime = (dropX / timelineRect.width) * $root.timelineDuration;
      const snappedTime = Math.max(0, Math.round(rawTime * 10) / 10);
      const targetRowIndex = Math.min(2, Math.floor(dropY / rowHeight));
      $root.dragPlaceholder.visible = true;
      $root.dragPlaceholder.left = `${(snappedTime / $root.timelineDuration) * 100}%`;
      $root.dragPlaceholder.width = `${($root.draggedBlockInfo.block.duration / $root.timelineDuration) * 100}%`;
      $root.dragPlaceholder.top = `${targetRowIndex * rowHeight + 1}px`;
      $root.dragPlaceholder.height = `${rowHeight - 2}px`;
    },
    onBlockDragLeave(event) {
      const timelineRect = this.$refs.timelineWrapper.getBoundingClientRect();
      if (event.clientX <= timelineRect.left || event.clientX >= timelineRect.right || event.clientY <= timelineRect.top || event.clientY >= timelineRect.bottom) {
        $root.dragPlaceholder.visible = false;
      }
    },
    onBlockDrop(event) {
      if (!$root.draggedBlockInfo) return;
      $root.dragPlaceholder.visible = false;
      const draggedBlock = $root.draggedBlockInfo.block;
      const timelineRect = this.$refs.timelineWrapper.getBoundingClientRect();
      const rowHeight = timelineRect.height / 3;
      const dropX = event.clientX - timelineRect.left - $root.draggedBlockInfo.offset;
      const dropY = event.clientY - timelineRect.top;
      const rawTime = (dropX / timelineRect.width) * $root.timelineDuration;
      const snappedTime = Math.max(0, Math.round(rawTime * 10) / 10);
      const targetRowIndex = Math.min(2, Math.floor(dropY / rowHeight));
      const allBlocksOnTargetRow = $root.project.images.flatMap(img => img.animationBlocks).filter(b => b.rowIndex === targetRowIndex);
      const hasOverlap = allBlocksOnTargetRow.some(b =>
        b.id !== draggedBlock.id &&
        (snappedTime < b.startTime + b.duration) &&
        (snappedTime + draggedBlock.duration > b.startTime)
      );
      if (hasOverlap) {
        $root.overlapError = true;
        setTimeout(() => $root.overlapError = false, 2000);
      } else {
        const imageOfBlock = this.getImageForBlock(draggedBlock);
        const blockToUpdate = imageOfBlock.animationBlocks.find(b => b.id === draggedBlock.id);
        if (blockToUpdate) {
          blockToUpdate.startTime = snappedTime;
          blockToUpdate.rowIndex = targetRowIndex;
          this.selectBlock(blockToUpdate);
          $root.updatePreview();
        }
      }
      $root.draggedBlockInfo = null;
    }
  }
}
</script>
