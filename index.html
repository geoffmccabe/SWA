
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>WebP Animation Editor</title>
    <style>
      /* --- GLOBAL STYLES --- */
      :root {
        --color-background: #1a1a1a;
        --color-surface: #2a2a2e;
        --color-surface-light: #3c3c42;
        --color-primary: #777777;
        --color-text: #eaeaea;
        --color-border: #555;
        --panel-gap: 10px;
        /* Desaturated colors w/ 50% Alpha */
        --color-pan: rgba(88, 121, 166, 0.5);
        --color-zoom: rgba(166, 82, 110, 0.5);
        --color-rotate: rgba(166, 106, 84, 0.5);
        --color-opacity: rgba(122, 88, 166, 0.5);
        --color-delete: #674445;
      }
      body {
        margin: 0;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
        background-color: var(--color-background);
        color: var(--color-text);
        overflow: hidden;
      }
      * {
        box-sizing: border-box;
      }

      /* --- LAYOUT --- */
      #app-container {
        display: flex;
        flex-direction: column;
        height: 100vh;
        position: relative;
      }
      .top-section { display: flex; flex-grow: 1; gap: var(--panel-gap); padding: var(--panel-gap); height: 60%; }
      .bottom-section { height: 40%; padding: 0 var(--panel-gap) var(--panel-gap); border-top: 1px solid var(--color-border); display: flex; flex-direction: column;}
      .panel { background-color: var(--color-surface); border-radius: 8px; padding: 15px; overflow: auto; }
      .top-section > .panel:nth-child(3) { overflow: hidden; }
      .placeholder-text, .placeholder-timeline { display: flex; align-items: center; justify-content: center; height: 100%; color: #888; font-style: italic; }

      /* --- FORMS & BUTTONS --- */
      button, .button-like {
        background-color: var(--color-primary); color: white; border: none; padding: 10px 15px;
        border-radius: 5px; cursor: pointer; font-size: 14px; transition: background-color 0.2s;
        width: 100%; margin-bottom: 10px; text-align: center; display: block;
      }
      button:hover, .button-like:hover { background-color: #666666; }
      button:disabled { background-color: #555; cursor: not-allowed; opacity: 0.7; }
      input, select {
        width: 100%; padding: 8px; background-color: var(--color-surface-light);
        border: 1px solid var(--color-border); color: var(--color-text);
        border-radius: 4px; margin-bottom: 10px;
      }
      .control-group { margin-bottom: 20px; }
      .control-group h3 { margin-top: 0; border-bottom: 1px solid var(--color-border); padding-bottom: 5px; font-size: 16px; }
      .help-text, label { font-size: 12px; color: #999; margin-bottom: 5px; display: block; }

      /* --- MIDDLE PANEL (THUMBNAILS) --- */
      .thumbnail-grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 10px;
      }
      .thumbnail-item {
        display: flex;
        flex-direction: column;
        gap: 4px;
        padding: 5px;
        border: 2px solid transparent;
        border-radius: 5px;
        cursor: pointer;
        background-color: var(--color-surface-light);
        min-width: 0;
      }
      .thumbnail-item.selected { border-color: var(--color-primary); }
      .thumbnail-item.drag-over { border-color: var(--color-primary); border-style: dashed; }
      .thumbnail-image-container {
        width: 100%;
        aspect-ratio: 1 / 1;
        background-color: var(--color-background);
        border-radius: 3px;
        display: flex;
        align-items: center;
        justify-content: center;
        overflow: hidden;
      }
      .thumbnail-image-container img {
        width: 100%;
        height: 100%;
        object-fit: contain;
        pointer-events: none;
      }
      .thumbnail-item span {
        font-size: 6px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        width: 100%;
        text-align: center;
      }

      /* --- CONTEXT MENU --- */
      .context-menu {
        position: fixed; background-color: #444; border: 1px solid var(--color-border);
        border-radius: 5px; box-shadow: 0 2px 10px rgba(0,0,0,0.5); z-index: 1000; width: 150px;
      }
      .context-item { padding: 10px 15px; cursor: pointer; }
      .context-item:hover { background-color: var(--color-primary); }

      /* --- RIGHT PANEL (PREVIEW) --- */
      .safari-warning {
        position: absolute; top: 10px; left: 10px; right: 10px; background-color: #ffc107;
        color: #333; padding: 10px; border-radius: 5px; font-size: 14px; text-align: center; z-index: 10;
      }
      .live-preview { max-width: 100%; max-height: 100%; object-fit: contain; }

      /* --- BOTTOM PANEL (TIMELINE) --- */
      .timeline-container { padding-top: 15px; display: flex; flex-direction: column; height: 100%; }
      .timeline-controls, .edit-form { padding: 10px; background-color: var(--color-surface); border-radius: 8px; margin-bottom: 15px; }
      .timeline-controls h4, .edit-form h4 { margin: 0 0 10px; }
      .timeline-controls .button-group {
        display: flex;
        gap: 10px;
      }
      .timeline-controls .button-group button {
        width: auto;
        flex-grow: 1;
        margin-bottom: 0;
      }
      .timeline-rows-wrapper { flex-grow: 1; position: relative; }
      .timeline-row { position: relative; height: 33.33%; border-top: 1px solid var(--color-border); }
      .timeline-row:first-child { border-top: none; }
      .time-ruler {
          position: absolute;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          pointer-events: none;
          z-index: 1;
      }
      .ruler-line { position: absolute; top: 0; bottom: 0; width: 1px; }
      .ruler-line.second { background-color: #333; }
      .ruler-line.tenth { background-color: #222; }
      .ruler-label {
          position: absolute;
          top: -15px;
          font-size: 10px;
          color: #999;
          transform: translateX(-50%);
      }
      .animation-block {
        position: absolute; height: calc(100% - 2px); top: 1px; border-radius: 4px; color: white;
        display: flex; align-items: center; justify-content: flex-start;
        font-size: 12px;
        cursor: pointer; overflow: hidden; white-space: nowrap; border: 1px solid rgba(255,255,255,0.3);
        z-index: 2;
        padding: 1px;
      }
      .block-thumbnail {
          height: 100%;
          aspect-ratio: 1 / 1;
          object-fit: cover;
          border-radius: 3px;
          margin-right: 5px;
          flex-shrink: 0;
      }
      .animation-block.selected { border-width: 2px; border-color: white; z-index: 10; }
      .animation-block.pan { background-color: var(--color-pan); }
      .animation-block.zoom { background-color: var(--color-zoom); }
      .animation-block.rotate { background-color: var(--color-rotate); }
      .animation-block.opacity { background-color: var(--color-opacity); }

      /* --- EDIT FORM --- */
      .edit-form .form-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 15px; }
      .edit-form .form-footer { display: flex; justify-content: space-between; align-items: center; margin-top: 15px; }
      .edit-form .checkbox-group { display: flex; flex-wrap: wrap; gap: 15px; }
      .edit-form .delete-btn { background-color: var(--color-delete); width: auto; margin-bottom: 0; }
      .loop-toggle { font-size: 14px; display: flex; align-items: center; gap: 5px; color: var(--color-text); cursor: pointer;}
      .loop-toggle input { width: auto; margin-bottom: 0; }

      .error-message {
        position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%);
        background-color: var(--color-delete); color: white; padding: 10px 20px;
        border-radius: 5px; z-index: 100;
      }
       .loading-overlay {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: rgba(0, 0, 0, 0.7);
        display: flex;
        align-items: center;
        justify-content: center;
        color: white;
        font-size: 20px;
        z-index: 2000;
      }
    </style>
</head>
<body>
    <div id="app" v-scope="App()">
        <div id="app-container">
            <div class="top-section">
        
              <div class="panel" style="flex: 1 1 auto;">
                <div class="control-group">
                  <h3>Project</h3>
                  <button @click="saveProject">Save Project</button>
                  <label class="button-like">Load Project
                    <input type="file" @change="handleProjectLoad" accept=".json" style="display: none;">
                  </label>
                  <button @click="exportSVG">Export SVG</button>
                  <button @click="exportVideo('mp4')" :disabled="isRendering">Export MP4</button>
                  <button @click="exportVideo('webp')" :disabled="isRendering">Export WebP</button>
                </div>
        
                <div class="control-group">
                  <h3>Images</h3>
                  <label class="button-like">Load Images
                    <input type="file" @change="handleImageUpload" multiple accept="image/webp,image/jpeg,image/png" style="display: none;">
                  </label>
                  <p class="help-text">Upload up to 10 WebP, JPG, or PNG files.</p>
                </div>
        
                <div class="control-group">
                  <h3>Dimensions</h3>
                  <label>Width (px)</label>
                  <input type="number" v-model="project.projectWidth">
                  <label>Height (px)</label>
                  <input type="number" v-model="project.projectHeight">
                </div>
              </div>
        
              <div class="panel" style="flex: 0 0 20%; min-width: 0;" @contextmenu.prevent>
                <div class="thumbnail-grid">
                    <div
                      v-for="(image, index) in sortedImages"
                      :key="image.id"
                      class="thumbnail-item"
                      :class="{ selected: image.id === project.selectedImageId, 'drag-over': dragOverIndex === index }"
                      :draggable="true"
                      @click="selectImage(image.id)"
                      @contextmenu.prevent="openContextMenu($event, image.id)"
                      @dragstart="onDragStart(index)"
                      @dragover.prevent="onDragOver(index)"
                      @dragleave="onDragLeave"
                      @drop="onDrop(index)"
                    >
                      <div class="thumbnail-image-container">
                          <img :src="image.base64Data" alt="thumbnail">
                      </div>
                      <span>{{ index + 1 }} - {{ image.name }}</span>
                    </div>
                </div>
                <div v-if="project.images.length === 0" class="placeholder-text">Upload images to begin</div>
                <div v-if="contextMenu.visible" class="context-menu" :style="{ top: contextMenu.y + 'px', left: contextMenu.x + 'px' }" @mouseleave="closeContextMenu">
                  <div class="context-item" @click="deleteImage(contextMenu.targetId)">Delete Image</div>
                </div>
              </div>
        
              <div class="panel" style="flex: 0 0 60%; display: flex; align-items: center; justify-content: center;">
                 <div v-if="isSafari" class="safari-warning">
                    Note: Live preview may not display correctly in Safari. Your export will still work.
                 </div>
                 <object type="image/svg+xml" :data="livePreviewSvgUrl" class="live-preview"></object>
              </div>
            </div>
        
            <div class="bottom-section">
              <div v-if="selectedImage" class="timeline-container">
                  <div v-if="selectedBlock" class="edit-form">
                      <h4>Edit {{ selectedBlock.type }} Animation</h4>
                      <div class="form-grid">
                          <div><label>Start Time (s)</label><input type="number" v-model="selectedBlock.startTime" min="0" step="0.1"></div>
                          <div><label>Duration (s)</label><input type="number" v-model="selectedBlock.duration" min="0.1" step="0.1"></div>
        
                          <template v-if="selectedBlock.type === 'pan'">
                              <div><label>Direction</label><select v-model="selectedBlock.parameters.direction"><option>left</option><option>right</option><option>up</option><option>down</option></select></div>
                              <div><label>Distance (px)</label><input type="number" v-model="selectedBlock.parameters.distance"></div>
                          </template>
                          <template v-if="selectedBlock.type === 'zoom'">
                              <div><label>Start Scale</label><input type="number" step="0.1" v-model="selectedBlock.parameters.startScale"></div>
                              <div><label>End Scale</label><input type="number" step="0.1" v-model="selectedBlock.parameters.endScale"></div>
                          </template>
                          <template v-if="selectedBlock.type === 'rotate'">
                              <div><label>Degrees</label><input type="number" v-model="selectedBlock.parameters.degrees"></div>
                              <div><label>Center X (px)</label><input type="number" v-model="selectedBlock.parameters.rotateX" :disabled="selectedBlock.parameters.useCenter"></div>
                              <div><label>Center Y (px)</label><input type="number" v-model="selectedBlock.parameters.rotateY" :disabled="selectedBlock.parameters.useCenter"></div>
                          </template>
                          <template v-if="selectedBlock.type === 'opacity'">
                              <div><label>Start Opacity</label><input type="number" step="0.1" min="0" max="1" v-model="selectedBlock.parameters.startOpacity"></div>
                              <div><label>End Opacity</label><input type="number" step="0.1" min="0" max="1" v-model="selectedBlock.parameters.endOpacity"></div>
                          </template>
                      </div>
                       <div class="form-footer">
                           <div class="checkbox-group">
                               <label class="loop-toggle"><input type="checkbox" v-model="selectedBlock.loop"> Loop</label>
                               <template v-if="selectedBlock.parameters.hasOwnProperty('autoReverse')">
                                   <label class="loop-toggle"><input type="checkbox" v-model="selectedBlock.parameters.autoReverse"> Auto-Reverse</label>
                               </template>
                                <template v-if="selectedBlock.type === 'rotate'">
                                   <label class="loop-toggle"><input type="checkbox" v-model="selectedBlock.parameters.useCenter"> Rotate Around Center</label>
                               </template>
                           </div>
                           <button class="delete-btn" @click="deleteAnimationBlock(selectedBlock.id)">Delete Block</button>
                       </div>
                  </div>
                  <div v-else class="timeline-controls">
                      <h4>Add Animation Block</h4>
                      <div class="button-group">
                        <button @click="addAnimationBlock('pan')">Pan</button>
                        <button @click="addAnimationBlock('zoom')">Zoom</button>
                        <button @click="addAnimationBlock('rotate')">Rotate</button>
                        <button @click="addAnimationBlock('opacity')">Opacity</button>
                      </div>
                  </div>
                  <div class="timeline-rows-wrapper" ref="timelineWrapper" @dragover.prevent @drop="onBlockDrop">
                      <div class="time-ruler">
                          <div v-for="mark in timelineMarks.tenths" :key="'tenth-' + mark" class="ruler-line tenth" :style="{ left: mark + '%' }"></div>
                          <div v-for="mark in timelineMarks.seconds" :key="'sec-' + mark.pos" class="ruler-line second" :style="{ left: mark.pos + '%' }"></div>
                          <div v-for="mark in timelineMarks.seconds" :key="'label-' + mark.pos" class="ruler-label" :style="{ left: mark.pos + '%' }">{{ mark.label }}s</div>
                      </div>
                      <div v-for="rowIndex in [0, 1, 2]" :key="rowIndex" class="timeline-row">
                          <div
                              v-for="block in getBlocksForRow(rowIndex)"
                              :key="block.id"
                              class="animation-block"
                              :class="[block.type, { 'selected': selectedBlock && selectedBlock.id === block.id }]"
                              :style="{ left: `${(block.startTime / timelineDuration) * 100}%`, width: `${(block.duration / timelineDuration) * 100}%` }"
                              draggable="true"
                              @dragstart="onBlockDragStart($event, block)"
                              @click="selectBlock(block)"
                          >
                              <img v-if="selectedImage" :src="selectedImage.base64Data" class="block-thumbnail">
                              <span>{{ block.type }}</span>
                          </div>
                      </div>
                      <div v-if="overlapError" class="error-message">Cannot overlap more than 3 animations.</div>
                  </div>
              </div>
              <div v-else class="placeholder-timeline">
                Select an image to view or add animations.
              </div>
            </div>
            <div v-if="isRendering" class="loading-overlay">
                Rendering...
            </div>
        </div>
    </div>
    
    <script src="https://unpkg.com/petite-vue"></script>
    <script>
      const { createApp } = PetiteVue;

      const BACKEND_URL = 'https://swa-exporter.up.railway.app'; 

      function App() {
        return {
          // --- STATE ---
          project: {
            projectWidth: 800,
            projectHeight: 600,
            images: [],
            selectedImageId: null,
          },
          selectedBlock: null,
          timelineDuration: 10,
          overlapError: false,
          isRendering: false,
          draggedBlockInfo: null,
          dragStartIndex: null,
          dragOverIndex: null,
          contextMenu: { visible: false, x: 0, y: 0, targetId: null },
          livePreviewSvgUrl: '',
          timelineWrapper: null,

          // --- COMPUTED ---
          get sortedImages() {
            return [...this.project.images].sort((a, b) => a.order - b.order);
          },
          get selectedImage() {
            if (!this.project.selectedImageId) return null;
            return this.project.images.find(img => img.id === this.project.selectedImageId);
          },
          get isSafari() {
             return /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
          },
          get timelineMarks() {
            const seconds = [];
            const tenths = [];
            const numSeconds = Math.floor(this.timelineDuration);

            for (let i = 0; i <= this.timelineDuration * 10; i++) {
                if (i % 10 !== 0) {
                    tenths.push(i * 100 / (this.timelineDuration * 10));
                }
            }
            for (let i = 0; i <= numSeconds; i++) {
                seconds.push({
                    pos: (i / this.timelineDuration) * 100,
                    label: i
                });
            }
            return { seconds, tenths };
          },
          
          // This computed property generates the SVG content string.
          // Any reactive property used inside it will trigger its re-calculation.
          get aSvgContent() {
            const { projectWidth, projectHeight, images } = this.project;
            const imagesToRender = [...images].sort((a, b) => b.order - a.order);
            const canvasCenterX = projectWidth / 2;
            const canvasCenterY = projectHeight / 2;

            const imageElements = imagesToRender.map(image => {
                const animationElements = image.animationBlocks.map(block => {
                    const repeatCount = block.loop ? 'indefinite' : '1';
                    
                    switch (block.type) {
                        case 'pan': {
                            const { direction, distance, autoReverse } = block.parameters;
                            const pans = { right: `${distance} 0`, left: `${-distance} 0`, up: `0 ${-distance}`, down: `0 ${distance}` };
                            const to = pans[direction];
                            if (autoReverse) {
                                return `<animateTransform attributeName="transform" type="translate" values="0 0; ${to}; 0 0" keyTimes="0; 0.5; 1" begin="${block.startTime}s" dur="${block.duration}s" repeatCount="${repeatCount}" additive="sum" />`;
                            }
                            return `<animateTransform attributeName="transform" type="translate" from="0 0" to="${to}" begin="${block.startTime}s" dur="${block.duration}s" repeatCount="${repeatCount}" additive="sum" />`;
                        }
                        case 'zoom': {
                            const { startScale, endScale, autoReverse } = block.parameters;
                            if (autoReverse) {
                                return `<animateTransform attributeName="transform" type="scale" values="${startScale}; ${endScale}; ${startScale}" keyTimes="0; 0.5; 1" begin="${block.startTime}s" dur="${block.duration}s" repeatCount="${repeatCount}" additive="sum" />`;
                            }
                            return `<animateTransform attributeName="transform" type="scale" from="${startScale}" to="${endScale}" begin="${block.startTime}s" dur="${block.duration}s" repeatCount="${repeatCount}" additive="sum" />`;
                        }
                        case 'rotate': {
                            const { degrees, autoReverse, useCenter, rotateX, rotateY } = block.parameters;
                            const cx = useCenter ? canvasCenterX : rotateX;
                            const cy = useCenter ? canvasCenterY : rotateY;
                            const midDegrees = degrees / 2;

                            if (autoReverse) {
                                return `<animateTransform attributeName="transform" type="rotate" values="0 ${cx} ${cy}; ${degrees} ${cx} ${cy}; 0 ${cx} ${cy}" keyTimes="0; 0.5; 1" begin="${block.startTime}s" dur="${block.duration}s" repeatCount="${repeatCount}" />`;
                            }
                            return `<animateTransform attributeName="transform" type="rotate" values="0 ${cx} ${cy}; ${midDegrees} ${cx} ${cy}; ${degrees} ${cx} ${cy}" keyTimes="0; 0.5; 1" begin="${block.startTime}s" dur="${block.duration}s" repeatCount="${repeatCount}" />`;
                        }
                        case 'opacity': {
                            const { startOpacity, endOpacity, autoReverse } = block.parameters;
                            if(autoReverse) {
                                return `<animate attributeName="opacity" values="${startOpacity}; ${endOpacity}; ${startOpacity}" keyTimes="0; 0.5; 1" begin="${block.startTime}s" dur="${block.duration}s" repeatCount="${repeatCount}" fill="freeze" />`;
                            }
                            return `<animate attributeName="opacity" from="${startOpacity}" to="${endOpacity}" begin="${block.startTime}s" dur="${block.duration}s" repeatCount="${repeatCount}" fill="freeze" />`;
                        }
                    }
                }).join('\n          ');
                
                return `
                <g>
                    <image href="${image.base64Data}" width="${projectWidth}" height="${projectHeight}" x="0" y="0" />
                    ${animationElements}
                </g>`;
            }).join('');
            
            return `<svg 
                width="${projectWidth}" 
                height="${projectHeight}" 
                xmlns="http://www.w3.org/2000/svg"
                >
                <defs>
                    <clipPath id="canvas-clip">
                        <rect x="0" y="0" width="${projectWidth}" height="${projectHeight}" />
                    </clipPath>
                </defs>
                <g clip-path="url(#canvas-clip)">
                    ${imageElements}
                </g>
            </svg>`;
          },

          // --- METHODS ---
          getBlocksForRow(rowIndex) {
            if (!this.selectedImage) return [];
            const rows = [[], [], []];
            const sortedBlocks = [...this.selectedImage.animationBlocks].sort((a, b) => a.startTime - b.startTime);
            for (const block of sortedBlocks) {
                let placed = false;
                for (let i = 0; i < 3; i++) {
                    const hasOverlap = rows[i].some(existingBlock => 
                        (block.startTime < existingBlock.startTime + existingBlock.duration) &&
                        (block.startTime + block.duration > existingBlock.startTime)
                    );
                    if (!hasOverlap) {
                        rows[i].push(block);
                        placed = true;
                        break;
                    }
                }
                if (!placed) { rows[0].push(block); }
            }
            return rows[rowIndex];
          },

          handleImageUpload(e) {
            const files = e.target.files;
            if (this.project.images.length + files.length > 10) {
                alert("Error: You can upload a maximum of 10 images.");
                return;
            }
            [...files].forEach(file => {
                const reader = new FileReader();
                reader.onload = (event) => {
                this.project.images.push({
                    id: `img_${Date.now()}_${Math.random()}`,
                    name: file.name,
                    base64Data: event.target.result,
                    order: this.project.images.length,
                    animationBlocks: [],
                });
                };
                reader.readAsDataURL(file);
            });
          },

          selectImage(id) {
            this.project.selectedImageId = id;
            this.selectedBlock = null;
          },

          deleteImage(id) {
              const imageToDelete = this.project.images.find(img => img.id === id);
              if (!imageToDelete) return;
              const deletedOrder = imageToDelete.order;
              this.project.images = this.project.images.filter(img => img.id !== id);
              this.project.images.forEach(img => {
                  if (img.order > deletedOrder) {
                      img.order--;
                  }
              });
              if (this.project.selectedImageId === id) {
                  this.project.selectedImageId = null;
              }
          },

          saveProject() {
            const projectJSON = JSON.stringify(this.project);
            localStorage.setItem('webpAnimatorProject', projectJSON);
            const blob = new Blob([projectJSON], { type: 'application/json' });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = 'my-animation-project.json';
            a.click();
            URL.revokeObjectURL(a.href);
          },

          handleProjectLoad(e) {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (event) => {
                try {
                const data = JSON.parse(event.target.result);
                if (data.projectWidth && data.projectHeight && Array.isArray(data.images)) {
                    this.project = data;
                    this.selectImage(data.selectedImageId || null);
                } else {
                    alert('Invalid project file format.');
                }
                } catch {
                alert('Error parsing project file.');
                }
            };
            reader.readAsText(file);
          },

          exportSVG() {
            const svgData = this.aSvgContent;
            const blob = new Blob([svgData], { type: 'image/svg+xml;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.style.display = 'none';
            a.href = url;
            a.download = 'animated-scene.svg';
            document.body.appendChild(a);
            a.click();
            URL.revokeObjectURL(url);
            document.body.removeChild(a);
          },

          async exportVideo(format) {
            if (!BACKEND_URL || BACKEND_URL === 'PASTE_YOUR_RAILWAY_URL_HERE') {
                alert('Backend URL is not configured. Please edit the index.html file.');
                return;
            }
            this.isRendering = true;
            try {
                const svgData = this.aSvgContent;
                const response = await fetch(`${BACKEND_URL}/api/render-${format}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ svg: svgData })
                });
                if (!response.ok) { throw new Error(`Server responded with status: ${response.status}`); }
                const blob = await response.blob();
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.style.display = 'none';
                a.href = url;
                a.download = `animation.${format}`;
                document.body.appendChild(a);
                a.click();
                URL.revokeObjectURL(url);
                document.body.removeChild(a);
            } catch (error) {
                console.error('Export failed:', error);
                alert(`Export failed. See console for details.`);
            } finally {
                this.isRendering = false;
            }
          },

          onDragStart(index) { this.dragStartIndex = index; },
          onDragOver(index) { this.dragOverIndex = index; },
          onDragLeave() { this.dragOverIndex = null; },
          onDrop(dropIndex) {
              if (this.dragStartIndex === null || this.dragStartIndex === dropIndex) {
                this.dragStartIndex = null;
                this.dragOverIndex = null;
                return;
              }
              const draggedImage = this.sortedImages[this.dragStartIndex];
              const targetImage = this.sortedImages[dropIndex];
              if (draggedImage && targetImage) {
                  const draggedOrder = draggedImage.order;
                  draggedImage.order = targetImage.order;
                  targetImage.order = draggedOrder;
              }
              this.dragStartIndex = null;
              this.dragOverIndex = null;
          },

          openContextMenu(event, imageId) {
            this.contextMenu.targetId = imageId;
            this.contextMenu.x = event.clientX;
            this.contextMenu.y = event.clientY;
            this.contextMenu.visible = true;
            window.addEventListener('click', this.closeContextMenu, { once: true });
          },
          closeContextMenu() { this.contextMenu.visible = false; },

          addAnimationBlock(type) {
            if (!this.selectedImage) return;
            const isLoopingByDefault = ['pan', 'zoom', 'rotate', 'opacity'].includes(type);
            const defaultParams = {
                pan: { direction: 'right', distance: 100, autoReverse: true },
                zoom: { startScale: 1, endScale: 1.5, autoReverse: true },
                rotate: { degrees: 360, autoReverse: false, useCenter: true, rotateX: 0, rotateY: 0 },
                opacity: { startOpacity: 1, endOpacity: 0, autoReverse: true },
            };
            const newBlock = {
                id: `anim_${Date.now()}`, type, startTime: 0, duration: 2, loop: isLoopingByDefault,
                parameters: defaultParams[type],
            };
            this.selectedImage.animationBlocks.push(newBlock);
            this.selectBlock(newBlock);
          },

          deleteAnimationBlock(id) {
            if (!this.selectedImage) return;
            this.selectedImage.animationBlocks = this.selectedImage.animationBlocks.filter(b => b.id !== id);
            if (this.selectedBlock && this.selectedBlock.id === id) {
                this.selectedBlock = null;
            }
          },

          selectBlock(block) { this.selectedBlock = block; },
        
          onBlockDragStart(event, block) {
              this.draggedBlockInfo = { blockId: block.id };
              event.dataTransfer.setData('text/plain', block.id);
              event.dataTransfer.effectAllowed = 'move';
          },
          
          onBlockDrop(event) {
              if (!this.draggedBlockInfo || !this.selectedImage || !this.$refs.timelineWrapper) return;
              const draggedBlock = this.selectedImage.animationBlocks.find(b => b.id === this.draggedBlockInfo.blockId);
              if (!draggedBlock) return;
              const timelineRect = this.$refs.timelineWrapper.getBoundingClientRect();
              const dropX = event.clientX - timelineRect.left;
              const rawTime = (dropX / timelineRect.width) * this.timelineDuration;
              const snappedTime = Math.max(0, Math.round(rawTime * 10) / 10);
              let placed = false;
              for (let i = 0; i < 3; i++) {
                  const rowToCheck = this.getBlocksForRow(i);
                  const hasOverlap = rowToCheck.some(existingBlock => 
                      (existingBlock.id !== draggedBlock.id) &&
                      (snappedTime < existingBlock.startTime + existingBlock.duration) &&
                      (snappedTime + draggedBlock.duration > existingBlock.startTime)
                  );
                  if (!hasOverlap) {
                      draggedBlock.startTime = snappedTime;
                      placed = true;
                      break; 
                  }
              }
              if (!placed) {
                  this.overlapError = true;
                  setTimeout(() => this.overlapError = false, 2000);
              }
              this.draggedBlockInfo = null;
          },
          
          // --- LIFECYCLE ---
          mounted() {
            this.timelineWrapper = this.$refs.timelineWrapper;
            const savedProject = localStorage.getItem('webpAnimatorProject');
            if (savedProject) {
                try {
                const data = JSON.parse(savedProject);
                this.project = data;
                } catch {
                localStorage.removeItem('webpAnimatorProject');
                }
            }
            // Watch for any changes in the project data and regenerate the preview
            this.$watch('aSvgContent', (newSvg) => {
                const blob = new Blob([newSvg], { type: 'image/svg+xml' });
                if (this.livePreviewSvgUrl) {
                    URL.revokeObjectURL(this.livePreviewSvgUrl);
                }
                this.livePreviewSvgUrl = URL.createObjectURL(blob);
            }, { immediate: true });
          }
        }
      }

      createApp(App()).mount('#app');
    </script>
</body>
</html>
